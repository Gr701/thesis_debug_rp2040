\section{Raspberry Pi and Pico-series}

In this thesis we will focus on the microcontrollers developed by the Raspberry Pi Holdings. The first predecessors of the modern boards, which we will look at, were developed by the Raspberry Pi Foundation with the educational purposes, but due to its low cost, compact size, and flexibility, the boards quickly gained recognition and popularity in other domains as well \cite{raspberry_history}. Nowadays, the Raspberry Pi products have a wide range of appliencies: from hobby projects to industrial automation, robotics and Internet of Things (IoT) \cite{raspberry_success}. 

rp2040 and rp2350

IoT

\section{Debugging theory}

The debugging is the integral part of the software development process. It includes finding and fixing the coding errors to ensure proper functioning and the performance of the software. There are different aproaches to debugging, with the simplest one being just printing program values to the output terminal. In this thesis we will focus on the automated debugging with the extended control over the program's execution, which allows the programmer to use the break points, step one line at a time through the code and monitor the values of the registers, variables and expressions throughout the process.

The approach described above is implemented for C and C++ with GNU Debugger, further reffered as GDB. First the program is compiled with "-g" flag, which besides the executable generates the lookup table for the debugger mapping binary code instructions to the code lines and variables. Then the program is started as a child process of the debugger, so it can control the interrupts.  

The debugging process applied to the embedded devices is different than the one used for the programs running on the host's CPU. That's because the debugger needs to control not the process on the host, but on the processing unit of the microcontroller. Below we will take a look at how the control commands are forwarded from the host environment to the CPU on the microcontroller, in other words, how the debugging pipeline is implemented for the embedded devices and in particular Pico-series microcontrollers.

\subsection{GDB}
\subsection{OpenOCD}
\subsection{Probe}
\subsection{SWD}
\subsection{JTAG}

    \begin{figure}[ht]
      \begin{center}
        \includegraphics*[width=\textwidth]{debug\_flush\_process}
      \end{center}
      \caption{The flush process during debugging.}
      \label{fig:debug_flush_process}
    \end{figure}

\section{Options and approaches}

Talk about working principles and dependencies for each option.

\subsection{Second Pico}
\subsection{off-the-shelf debugger module from RP}
\subsection{second core debugger (STM32)}
\subsection{Faster probe forum}

    * git - https://github.com/essele/pico\_debug \\
    * last commit 4 years ago, not maintained \\
    * https://community.platformio.org/t/debugging-raspberry-pi-pico/30946 (discussion)

\subsection{Black Magic probe}

    * to use black magic you need more mana

\subsection{JTAG/SWD Segger debugger}

\section{TKJHat and the Computer Systems course}
